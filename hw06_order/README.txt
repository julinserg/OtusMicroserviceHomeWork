1. Манифесты - https://github.com/julinserg/otus-microservice-hw/tree/main/hw06_order/deployments/kubernetes
2. Перед применением манифестов необходимо установить постгрес командой - из helm - sudo helm install pg1 oci://registry-1.docker.io/bitnamicharts/postgresql -f <путь до values.yaml>
Сам values.yaml - https://github.com/julinserg/otus-microservice-hw/blob/main/hw06_order/deployments/pg-helm-values/values.yaml
3. Коллекция тестов постман - https://github.com/julinserg/otus-microservice-hw/blob/main/hw06_order/test/postman/OrdersTest.json
4. Код обработчиков запросов - https://github.com/julinserg/otus-microservice-hw/blob/main/hw06_order/internal/orders/server/http/handlers.go
Код работы с БД и с транзакциями - https://github.com/julinserg/otus-microservice-hw/blob/main/hw06_order/internal/orders/storage/sql/storage.go

Описание реализации:
1. Реализовал сервис "Заказ" из одной функции "создание заказа". На вход сервису приходит http-запрос содержащий http-заголовок с ID запроса X-Request-Id и телом с параметрами заказа в формате json.
2. При получение такого запроса сервис создает в БД соответствующую запись о создании нового заказа и присвоит этому заказу новый уникальный ID (ID-заказа).
3. Цель - сделать создание нового заказа идемпотентной операцией, то есть чтобы при отправке нового запроса на создание заказа с тем же самым X-Request-Id новая запись о заказе в БД не создавалась (и новый ID-заказа не генерировался).
4. Решение - завести таблицу в БД с привязкой X-Request-Id к коду http-ответа и при получении запроса проверять, если такой X-Request-Id в БД уже есть, значит запрос уже обрабатывается или уже был обработан и нужно просто вернуть пользователю код http-ответа, если такого X-Request-Id в БД нет, то создаем и затем создаем сам заказ в БД присваивая ему ID-заказа. Если запрос уже обработан, то отдаем соответствующий код http-ответа (если не было ошибки, то 200, если была ошибка, то соответствующий код ошибки), а если запрос еще обрабатывается, то просто отдаем 200, оптимистично считая, что запрос закончится успешным выполнением.
5. Проблема такого решения - нет защиты от конкурентного доступа. Так как веб-сервер асинхронный то ему могут придти на обработку два запроса "одновременно" и "одновременно" вызовутся два обработчика запроса которые "одновременно" пойдут в БД и не найдут там X-Request-Id и станут создавать заказ - в итоге создастся два заказа. Блокировка обработчика мьютексом в данном случае не поможет так как сервис запущен в нескольких экземплярах через балансировщик нагрузки и два запроса могут придти "одновременно" на разные экземпляры сервиса.
6. Решение - использовать блокировки на уровне БД. Операция чтения и записи X-Request-Id должна быть транзакционной. Тогда при уровне изоляций транзакции read committed БД гарантирует последовательное выполнение двух "одновременных" транзакции.
7. Для проверки написаны 3 теста - первые 2 создают два одинаковых заказа с одним и тем же X-Request-Id, третий - проверяет количество созданных заказов (количество записей в БД с уникальным ID-заказа). При запуске через Postman создана нагрузка из 50 виртуальных пользователей, которые выполняют эти тесты в течение 1 минуты. В результате в БД всегда 1 заказ.
